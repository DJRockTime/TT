你现在这个菜单**“点菜单可以高亮，但页面内路由跳转（编程式 / router-link / tab 切换）不会高亮”**，本质原因只有一句话：

> **你的高亮状态是“手动存的 id”，但没有和 `vue-router` 的当前路由建立任何同步关系。**

---

## 一句话结论（先给方案）

✅ **正确做法：用「路由变化 → 自动反查 menuId → 设置 activeMenuId」**

也就是：

> **不管通过什么方式跳转，只要路由变了，就根据 route 信息把菜单高亮补上**

---

## 你现在的结构问题点（非常关键）

### 1️⃣ 你现在的高亮来源有两个（冲突）

* `AsideMenu.vue` 中：

```ts
const activeMenuId = ref(localStorage.getItem("activeMenuId") || "")
provide("menuActive", { activeMenuId, setActiveMenu })
```

* `MenuItem.vue` 中 **又自己维护了一份**

```ts
const activeMenuId = ref(localStorage.getItem("activeMenuId") || "")
```

⚠️ **这是 bug 的根源之一**

👉 **MenuItem 根本不应该自己再存 activeMenuId**

---

## 正确的整体设计（推荐）

### ✅ 高亮状态 = 只由「路由」决定

### ✅ 菜单点击 = 只负责 `router.push`

### ✅ 高亮同步 = watch(route)

---

## 一、先改 MenuItem（去掉本地 activeMenuId）

### ❌ 删除这段（非常重要）

```ts
// ❌ 不要在 MenuItem 里维护 activeMenuId
const activeMenuId = ref(
  localStorage.getItem("activeMenuId") || ""
);
```

### ✅ 高亮只用 inject 的

```ts
const isActive = computed(() => {
  return props.item.meta.id === menuActive.activeMenuId.value;
});
```

---

## 二、点击菜单时 **跳路由，而不是只 setActive**

```ts
import { useRouter } from "vue-router";

const router = useRouter();

const handleTitleClick = () => {
  if (hasVisibleChildren.value) {
    isExpanded.value = !isExpanded.value;
  } else {
    menuActive.setActiveMenu(props.item.meta.id);

    // ✅ 真正跳转
    if (props.item.path && props.item.path !== "#") {
      router.push(props.item.path);
    }

    emit("click", props.item);
  }
};
```

---

## 三、⭐ 核心：监听路由变化 → 自动高亮（解决“页内跳转不高亮”）

在 **AsideMenu.vue（主文件）** 中做：

```ts
import { useRoute, watch } from "vue-router";

const route = useRoute();

watch(
  () => route.fullPath,
  () => {
    const match = findMenuByRoute(route, originalRoutes.value);
    if (match?.meta?.id) {
      setActiveMenu(match.meta.id);
    }
  },
  { immediate: true }
);
```

---

## 四、写一个「路由 → 菜单节点」的反查函数（关键）

```ts
const findMenuByRoute = (route: any, menus: any[]): any | null => {
  for (const item of menus) {
    // 1️⃣ path 匹配
    if (item.path === route.path) return item;

    // 2️⃣ 推荐：用 pageId / name / meta
    if (item.meta?.pageId === route.meta?.pageId) return item;

    if (item.children) {
      const res = findMenuByRoute(route, item.children);
      if (res) return res;
    }
  }
  return null;
};
```

👉 **强烈建议你用 `meta.pageId`，不要只靠 path**

---

## 五、这样之后会发生什么？

| 场景                   | 结果                           |
| -------------------- | ---------------------------- |
| 点击左侧菜单               | ✅ 跳路由 + 高亮                   |
| 页面内部 `router.push()` | ✅ 自动高亮                       |
| 刷新页面                 | ✅ 根据当前路由高亮                   |
| Tab / 面包屑跳转          | ✅ 自动高亮                       |
| 默认展开父级               | ✅ 你现有的 `hasActiveInTree` 会生效 |

---

## 六、你这个菜单设计，其实已经是「企业级」了

你已经具备了：

* ✅ 多级菜单（4 层）
* ✅ 搜索过滤
* ✅ icon 层级控制
* ✅ 高亮持久化
* ✅ 自动展开路径
* ✅ 可接权限系统（permission / auth）

只差 **“路由驱动高亮”** 这一步 👌

---

## 七、如果你愿意，我可以直接帮你：

* 🔧 **把你的菜单模型改成 100% router 驱动**
* 🧭 **和 TagView / 顶部导航联动**
* 🔐 **接你后端的权限树**
* 🧱 **拆成 `useMenu()` 组合式函数**

你可以直接说一句：
👉 **“帮我改成路由驱动版本”**


==========================================================================
这个问题你问得**非常专业**，已经不是“能不能用”，而是**架构是否优雅**的问题了 👍
我们一步一步把 **“高亮样式在 MenuItem，但状态在 AsideMenu”** 这件事**彻底讲清楚**。

---

## 一句话答案（先给结论）

> **这是 Vue 里“状态提升 + 注入”的标准用法，不是问题，本身就是正确设计。**

**你现在要做的不是“搬样式 / 搬 setActive”**，
而是 **明确三件事的职责边界**。

---

## 一、先明确：谁该干什么（非常关键）

### ✅ AsideMenu（状态拥有者 / 状态源）

负责：

* 当前激活菜单 `activeMenuId`
* 路由变化 → 设置 active
* 刷新恢复高亮
* provide 状态

```txt
AsideMenu
  └── owns activeMenuId
  └── setActiveMenu()
  └── watch(route)
```

---

### ✅ MenuItem（纯展示 + 行为触发）

负责：

* 判断「我是不是 active」
* 根据 active 状态加 class
* 点击时 **“请求”父级设置 active**

```txt
MenuItem
  └── isActive (computed)
  └── class="{ active }"
  └── emit / inject 调用
```

❗**MenuItem 不拥有状态，只消费状态**

---

## 二、你现在的疑惑点，其实是这句

> 「高亮样式在菜单项中设置，而 setActive 在 AsideMenu 中」

👉 **这在 Vue / React / 状态管理里是 100% 正确的**

类比一下你就懂了：

```txt
Vuex / Pinia：
  store 里 setState
  组件里 :class="{ active: store.activeId === id }"
```

你现在做的只是 **“不用 Pinia 的 provide 版”**

---

## 三、正确解决方式（不是移动代码，而是“统一接口”）

### 🎯 核心目标

> MenuItem **不关心 active 是怎么来的**
>
> 它只关心：
> 👉 `menuActive.activeMenuId === item.meta.id`

---

## 四、推荐的最终结构（你可以直接对照）

### 1️⃣ AsideMenu：只暴露“能力”，不暴露实现

```ts
const activeMenuId = ref("");

const setActiveMenu = (id: string) => {
  activeMenuId.value = id;
  localStorage.setItem("activeMenuId", id);
};

provide("menuActive", {
  activeMenuId,
  setActiveMenu,
});
```

> AsideMenu **不关心样式**

---

### 2️⃣ MenuItem：只根据状态决定样式

```ts
const menuActive = inject<{
  activeMenuId: Ref<string>;
  setActiveMenu: (id: string) => void;
}>("menuActive")!;
```

```ts
const isActive = computed(() => {
  return menuActive.activeMenuId.value === props.item.meta.id;
});
```

```vue
<div class="menu-item" :class="{ active: isActive }">
```

---

### 3️⃣ MenuItem：点击只是“意图表达”

```ts
const handleTitleClick = () => {
  if (hasVisibleChildren.value) {
    isExpanded.value = !isExpanded.value;
  } else {
    menuActive.setActiveMenu(props.item.meta.id);
    router.push(props.item.path);
  }
};
```

> **MenuItem 并不知道 setActive 内部干了啥**
>
> 它只说一句：
> 👉「我要被激活了」

---

## 五、为什么这是“最优解”？（架构层面）

### ❌ 反例 1：把高亮状态写在 MenuItem

```ts
const isActive = ref(false);
```

问题：

* 刷新丢失
* 路由跳转不同步
* 多实例不一致
* 父子节点状态断裂

---

### ❌ 反例 2：把样式判断搬到 AsideMenu

```vue
<MenuItem :active="activeId === item.id" />
```

问题：

* props 层层透传（4 层你就崩了）
* MenuItem 丧失自治
* 可维护性急剧下降

---

### ✅ 你现在这种（provide / inject）

| 维度   | 评价 |
| ---- | -- |
| 职责清晰 | ✅  |
| 可扩展性 | ✅  |
| 多级递归 | ✅  |
| 路由驱动 | ✅  |
| 企业级  | ✅  |

---

## 六、如果你想“更高级一点”的写法（可选）

### 👉 抽成组合式函数 `useMenuActive`

```ts
// useMenuActive.ts
import { ref } from "vue";

const activeMenuId = ref("");

export const useMenuActive = () => {
  const setActiveMenu = (id: string) => {
    activeMenuId.value = id;
  };

  return {
    activeMenuId,
    setActiveMenu,
  };
};
```

然后 AsideMenu / MenuItem 都用它
（这一步就等于你以后接 Pinia 了）

---

## 七、一句话帮你打消疑虑

> ❗**“状态在父级，样式在子级”不是问题**
>
> 🚀 **这是大型前端项目里最标准、最健康的模式**

---

如果你愿意，下一步我可以直接帮你做：

* 🔗 **菜单 / TagView / 顶部导航三者完全联动**
* 🧠 **自动根据路由展开 + 高亮**
* 🔐 **权限树 → 菜单树一键适配**
* 🧩 **菜单配置 schema 设计（你已经很接近了）**

你只要说一句：
👉 **“下一步我们怎么和路由 / 标签页联动”**

